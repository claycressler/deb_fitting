\documentclass[12pt,reqno,final,pdftex]{amsart}
%% DO NOT DELETE OR CHANGE THE FOLLOWING TWO LINES!
%% $Revision$
%% $Date$
\usepackage[round,sort,elide]{natbib}
\usepackage{graphicx}
\usepackage{times}
\usepackage{rotating}
\usepackage{subfig}
\usepackage{comment}
\usepackage{color}
\newcommand{\aak}[1]{\textcolor{cyan}{#1}}
\newcommand{\mab}[1]{\textcolor{red}{#1}}
\newcommand{\cec}[1]{\textcolor{blue}{#1}}

\setlength{\textwidth}{6.25in}
\setlength{\textheight}{8.75in}
\setlength{\evensidemargin}{0in}
\setlength{\oddsidemargin}{0in}
\setlength{\topmargin}{-.35in}
\setlength{\parskip}{.1in}
\setlength{\parindent}{0.3in}

%% cleveref must be last loaded package
\usepackage[sort&compress]{cleveref}
\newcommand{\crefrangeconjunction}{--}
\crefname{figure}{Fig.}{Figs.}
\Crefname{figure}{Fig.}{Figs.}
\crefname{table}{Table}{Tables}
\Crefname{table}{Tab.}{Tables}
\crefname{equation}{Eq.}{Eqs.}
\Crefname{equation}{Eq.}{Eqs.}
\crefname{appendix}{Appendix}{Appendices}
\Crefname{appendix}{Appendix}{Appendices}
\creflabelformat{equation}{#2#1#3}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{corol}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{defn}[thm]{Definition}
\newtheorem{hyp}[thm]{Hypothesis}
\newtheorem{example}[thm]{Example}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{algorithm}[thm]{Algorithm}
\newtheorem{remark}{Remark}
\renewcommand\thethm{\arabic{thm}}
\renewcommand{\theremark}{}

\numberwithin{equation}{part}
\renewcommand\theequation{\arabic{equation}}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thefigure{\arabic{figure}}
\renewcommand\thetable{\arabic{table}}
\renewcommand\thefootnote{\arabic{footnote}}

\newcommand\scinot[2]{$#1 \times 10^{#2}$}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\pkg}[1]{\textsf{#1}}
\newcommand{\dlta}[1]{{\Delta}{#1}}
\newcommand{\Prob}[1]{\mathbb{P}\left[#1\right]}
\newcommand{\Expect}[1]{\mathbb{E}\left[#1\right]}
\newcommand{\Var}[1]{\mathrm{Var}\left[#1\right]}
\newcommand{\dd}[1]{\mathrm{d}{#1}}
\newcommand{\citetpos}[1]{\citeauthor{#1}'s \citeyearpar{#1}}

\begin{document}

<<setup,include=FALSE,cache=F>>=
require(knitr)
opts_chunk$set(
               progress=T,prompt=F,tidy=F,highlight=T,
               warning=F,message=F,error=F,
               results='hide',echo=F,cache=T,
               size='scriptsize',
               fig.path='figure/',fig.lp="fig:",
               fig.align='left',
               fig.show='asis',
               fig.height=4,fig.width=6.83,
               out.width="\\linewidth",
               dpi=150,
               dev=c('png','tiff'),
               dev.args=list(
                 png=list(bg='transparent'),
                 tiff=list(compression='lzw')
                 )
               )

scinot <- function (x, digits = 2, type = c("expression","latex")) {
  type <- match.arg(type)
  x <- signif(x,digits=digits)
  ch <- floor(log10(abs(x)))
  mn <- x/10^ch
  switch(type,
         expression={
           bquote(.(mn)%*%10^.(ch))
         },
         latex={
           paste0("\\scinot{",mn,"}{",ch,"}")
         }
         )
}

require(xtable)

options(scipen=-1)

options(
        xtable.caption.placement="top",
        xtable.include.rownames=FALSE
        )

@

\subsection*{Preliminaries}
The data that we are trying to fit with the full DEB model with parasitism is of the body size and parasite load of individual \emph{Daphnia}.
Before attempting to fit all of this data, it is worth attempting to fit only the growth data.
This is because, if we cannot fit the growth data, we will not be able to fit both the growth and parasite load data.
Moreover, fitting only the growth data is more straightforward, as we already have a good model for growth.
My assumption (and the assumption of most people), is that \emph{Pasteuria} modifies the growth of individual \emph{Daphnia} by increasing the fraction of mobilized energy that is allocated towards growth ($\kappa$).
In so doing, the parasite causes both gigantism and castration.
However, it is worth asking whether the parasite also modifies other aspects of the energy budget, especially in light of the fact that infection causes a reduction in host foraging.
This reduction in resource ingestion could compromise the ability to induce gigantism.
To address this question, I will fit the following model to the growth data of infected animals:
\begin{align}
\frac{dF}{dt} &= -I_{max} \frac{F}{F_h+F} L^g, \\
\frac{dE}{dt} &= \rho \epsilon V I_{max} \frac{F}{F_h+F} L^g - \frac{E (v/L + k_m)}{1+\kappa E/W}, \\
\frac{dW}{dt} &= \kappa \frac{E (v/L + k_m)}{1+\kappa E/W} - k_m W.
\end{align}

I will assume that the energy budget parameters (the assimilation efficiency, $\rho$; the energy conductance, $v$; and the somatic maintenance rate, $k_m$) have the same value as in uninfected animals.
I will assume the the ingestion parameters (ingestion rate, $I_{max}$ and shape parameter $g$) take on the best-fitting values when this feeding model was fit to the ingestion data.
The half-saturation constant, $F_h$, proved impossible to estimate then, but based on Fig. 2 in the document ``Notes\_feeding\_model.pdf'', $g$ is nearly constant across a range of fixed $F_h$ values, whereas $I_{max}$ increases linearly with $F_h$.
I will assume $F_h=10000$, which implies that $g=0.156$ and $I_{max}=14250$.
The size of the experimental container $V$ and the carbon content of an algae cell $\epsilon$ are both fixed at their known values.
That leaves only the growth allocation $\kappa$ to be estimated.

The maximum likelihood estimate of $\kappa$, according to the data, is $\kappa=1$, as expected.
However, even with $\kappa=1$, the fit to the data is very poor (Fig. \ref{fig:inf-length}): the maximum possible size of the animals is far less than is actually observed in the data.
\textbf{This suggests that the parasite must be adjusting other aspects of the energy budget in order to induce gigantism, especially in the face of infection-induced foraging reduction.}
There are two possibilities: the parasite either reduces somatic maintenance rates or increases assimilation efficiency (modifying the energy conductance has no effect on the fit).

As an aside, this also explains past difficulties with fitting the parasite data: the model can't fit the observed growth \emph{before} adding a parasitic drain on reserves or biomass; with that additional drain on energy, there is no way to remotely fit the growth data.
In past fitting attempts, it was clear that the fitting algorithm was exploring parameter space where the impact of the parasite on the host energy budget was minimal, while simultaneously inflating the variance in parasite load measurement error.


<<inf-length, echo=FALSE, fig.height=4, fig.width=4, units='in', res=300, fig.cap='The best-fitting growth model for infected animals when most of the parameters are held fixed at their uninfected values except for the feeding parameters (infected animals eat less) and the growth allocation $\\kappa$. Even with $\\kappa$ maximized, the model fits the data poorly - the animals are unable to grow as large as is observed in the actual data.'>>=
source("Growth_trajectory_matching_infecteds.R")
model <- "deb_parasite_growth_only"
#dyn.load(paste0(model,'.dll')) ## PC
dyn.load(paste0(model,'.so')) ## Mac

x <- read.csv("Cat_data/all_data.csv") %>% as.data.frame
x2 <- subset(x, infected==1)
data <- x2[,c("day.of.assay","length..mm.","Spore.per.animal")]
colnames(data) <- c("age","length","spores")
## how to deal with 0s?
data$spores[is.na(data$spores)] <- 0

## parameters fixed at the uninfected data values
fixpars <- c(rho=0.152, km=0.073, v=10, F0=1e6/30, Lobs=0.0102)

## estimated parameters for this parasite model
estpars <- c(K=0.9999)

## unconstrained scale transformation
transform <- 'logit'

## ensure that the parameters are in the correct order for the model function
pars <- c(estpars, fixpars)
parorder <- c("rho","K","km","v","F0","Lobs")
pars[match(parorder, names(pars))] -> pars

## Generic set of food addition events
eventdat <- data.frame(var="F",
                       time=1:35,
                       value=unname(pars["F0"]),
                       method=rep(c(rep("add",4),"rep"),max(data$age)/5))

## Initial condition: assuming that E/W = rho/v and E+W=ER, then W
## + W*rho/v = ER, W(1+rho/v)=ER, W=ER/(1+rho/v)
y0 <- c(F=unname(pars["F0"]),
        E=0,
        W=unname(5.39e-5/(1+pars["rho"]/pars["v"])))
y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])

## Simulate the system
try(ode(y0,
        times=seq(0,35,0.1),
        func="derivs",
        parms=pars,
        dllname=model,
        initfunc="initmod",
        events=list(data=eventdat))) -> out
as.data.frame(out[out[,'time']%in%data$age,]) -> pred

## compute the observed weight as Wobs = W + E and compute the observed length prediction as Wobs=xi*Lobs^q; (Wobs/xi)^(1/q)=Lobs
xi <- 1.8e-3; q <- 3;
mutate(pred, Wobs=W+E, Lobs=(Wobs/xi)^(1/q)) -> pred

## compute the probability of observing the data, given the prediction
sapply(unique(data$age),
               function(d)
                   dnorm(x=data$length[data$age==d],
                         mean=pred$Lobs[pred$time==d],
                         sd=pars["Lobs"],
                         log=TRUE) %>% sum
               ) %>% sum -> lik

tm_obj(par_transform(estpars, transform), data, fixpars, parorder, transform, model)

optimizer(estpars, fixpars, parorder, transform, data, model, eval.only=TRUE, method="Nelder-Mead")

tm_obj_2(K=0.9999, data, fixpars, parorder, model)

## one dimensional optimization
Kopt <- optimize(f=tm_obj_2, interval=c(0,1), tol=1e-5, data=data, fixpars=fixpars, parorder=parorder, model=model)
## Kopt is maximized at K=1

with(mutate(as.data.frame(out), Wobs=W+E, Lobs=(Wobs/xi)^(1/q)), plot(time, Lobs, type='l', ylim=c(0.3,2), xlab="Age", ylab="Length (mm)"))
with(data, points(age, length))



@

We can fit the model to the growth data to determine how much infection is adjusting these values.
If we allow the assimilation efficiency $\rho$ to vary, the model fit improves considerably (Fig. \ref{fig:inf-length-2}).
Allowing somatic maintenance rate to vary improves the fit even more.
In particular, if I only want to let infection adjust one parameter, the one that is best supported is the somatic maintenance rate, which is \emph{dramatically} reduced by infection (from an uninfected baseline of 0.073 to 0.0013).
If you let both parameters be flexible, then the best supported model is one where the parasite reduces assimilation effiency slightly while greatly reducing somatic maintenance rate.
\textbf{If we take this result seriously, it suggests that the metabolic rates of infected animals may be much lower than their uninfected counterparts.}

<<'inf-length-2', fig.height=3, fig.width=6, units='in', res=300, fig.cap='Best-fitting growth trajectories when parasites are able to adjust growth allocation and either assimilation efficiency, somatic maintenance rate, or both.'>>=
estpars <- c(rho=0.152, K=0.9999)
fixpars <- c(km=0.073, v=10, F0=1e6/30, Lobs=0.0102)
pars <- c(estpars, fixpars)
parorder <- c("rho","K","km","v","F0","Lobs")
pars[match(parorder, names(pars))] -> pars
transform <- c('logit','logit')
optimizer(estpars, fixpars, parorder, transform, data, model, eval.only=TRUE, method="Nelder-Mead")

opt <- optimizer(estpars, fixpars, parorder, transform, data, model, eval.only=FALSE, method="Nelder-Mead")

estpars <- opt$params
fixpars <- c(km=0.073, v=10, F0=1e6/30, Lobs=0.0102)
pars <- c(estpars, fixpars)
parorder <- c("rho","K","km","v","F0","Lobs")
pars[match(parorder, names(pars))] -> pars
eventdat <- data.frame(var="F",
                       time=1:35,
                       value=unname(pars["F0"]),
                       method=rep(c(rep("add",4),"rep"),max(data$age)/5))
y0 <- c(F=unname(pars["F0"]),
        E=0,
        W=unname(5.39e-5/(1+pars["rho"]/pars["v"])))
y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])
try(ode(y0,
        times=seq(0,35,0.1),
        func="derivs",
        parms=pars,
        dllname=model,
        initfunc="initmod",
        events=list(data=eventdat))) -> out

par(mfrow=c(1,3), mar=c(5,5,0.5,0.5), oma=rep(0,4))
with(mutate(as.data.frame(out), Wobs=W+E, Lobs=(Wobs/xi)^(1/q)), plot(time, Lobs, type='l', ylim=c(0.3,2), xlab="Age", ylab="Length (mm)"))
with(data, points(age, length))
text(x=25, y=0.6, c("K=1\np=0.197\n-loglik=18150"))

##############################3

estpars <- c(K=0.9999, km=0.073)
fixpars <- c(rho=0.152, v=10, F0=1e6/30, Lobs=0.0102)
pars <- c(estpars, fixpars)
parorder <- c("rho","K","km","v","F0","Lobs")
pars[match(parorder, names(pars))] -> pars
transform <- c('log','logit')
optimizer(estpars, fixpars, parorder, transform, data, model, eval.only=TRUE, method="Nelder-Mead")

opt <- optimizer(estpars, fixpars, parorder, transform, data, model, eval.only=FALSE, method="Nelder-Mead")

estpars <- opt$params
fixpars <- c(rho=0.152, v=10, F0=1e6/30, Lobs=0.0102)
pars <- c(estpars, fixpars)
parorder <- c("rho","K","km","v","F0","Lobs")
pars[match(parorder, names(pars))] -> pars
eventdat <- data.frame(var="F",
                       time=1:35,
                       value=unname(pars["F0"]),
                       method=rep(c(rep("add",4),"rep"),max(data$age)/5))
y0 <- c(F=unname(pars["F0"]),
        E=0,
        W=unname(5.39e-5/(1+pars["rho"]/pars["v"])))
y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])
try(ode(y0,
        times=seq(0,35,0.1),
        func="derivs",
        parms=pars,
        dllname=model,
        initfunc="initmod",
        events=list(data=eventdat))) -> out

with(mutate(as.data.frame(out), Wobs=W+E, Lobs=(Wobs/xi)^(1/q)), plot(time, Lobs, type='l', ylim=c(0.3,2), xlab="Age", ylab="Length (mm)"))
with(data, points(age, length))
text(x=25, y=0.6, c("K=1\nkm=0.0013\n-loglik=8237"))

#########################3

estpars <- c(rho=0.152, K=0.9999, km=0.073)
fixpars <- c(v=10, F0=1e6/30, Lobs=0.0102)
pars <- c(estpars, fixpars)
parorder <- c("rho","K","km","v","F0","Lobs")
pars[match(parorder, names(pars))] -> pars
transform <- c('logit','logit','log')
optimizer(estpars, fixpars, parorder, transform, data, model, eval.only=TRUE, method="Nelder-Mead")

opt <- optimizer(estpars, fixpars, parorder, transform, data, model, eval.only=FALSE, method="Nelder-Mead")

estpars <- opt$params
fixpars <- c(v=10, F0=1e6/30, Lobs=0.0102)
pars <- c(estpars, fixpars)
parorder <- c("rho","K","km","v","F0","Lobs")
pars[match(parorder, names(pars))] -> pars
eventdat <- data.frame(var="F",
                       time=1:35,
                       value=unname(pars["F0"]),
                       method=rep(c(rep("add",4),"rep"),max(data$age)/5))
y0 <- c(F=unname(pars["F0"]),
        E=0,
        W=unname(5.39e-5/(1+pars["rho"]/pars["v"])))
y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])
try(ode(y0,
        times=seq(0,35,0.1),
        func="derivs",
        parms=pars,
        dllname=model,
        initfunc="initmod",
        events=list(data=eventdat))) -> out

with(mutate(as.data.frame(out), Wobs=W+E, Lobs=(Wobs/xi)^(1/q)), plot(time, Lobs, type='l', ylim=c(0.3,2), xlab="Age", ylab="Length (mm)"))
with(data, points(age, length))
text(x=25, y=0.6, c("K=1\nkm=0.0013\np=0.117\n-loglik=8200"))

@

\subsection*{Models of parasite growth and development}

There are many different possibilities for the model of parasite replication, but I want to consider three basic variants that differ in terms of where the parasite gets its energy.
The first assumes that parasites use reserves as a resource, as in Hall et al. 2009.
The second assumes that parasites use soma as a resource.
Within each of these different energetic architectures, there are multiple possible ways to model parasite replication and development, so I will consider several variants for each.

\subsection*{Models of exploitation of reserves}
Here I will assume that \emph{Pasteuria} exploits reserves, so there will be an additional negative term in the $dE/dt$ equation which is the parasite's ``functional response'', $a_P P$.
The parasite's equation will take one of five forms:
\begin{align}
(1) \frac{dP}{dt} &= \epsilon_P a_P E P, \\
(2) \frac{dP}{dt} &= \epsilon_P a_P E P - m P, \\
(3) \frac{dP}{dt} &= \epsilon_P a_P E P \left(1 - \frac{P}{k_P W}\right).
\end{align}
The third equation assumes that the parasite's growth rate is
logistic, with a carrying capacity that is determined by the
\emph{size} of the host.
This makes sense, especially for \emph{Pasteuria}, as the parasite
essentially completely fills the hemolymph near the end of infection,
and it is thought that the benefit of gigantism to the parasite might
simply be that it increases the total volume that can be filled with
parasite spores.

I also consider structured-population versions of these equations,
where the parasite can be divided into replicating and non-replicating
stages ($P_i$ and $P_m$).
I assume that the replicating stage exploits resources eventually
matures into a non-replicating stage.
This approximates our best understanding of the biology of
\emph{Pasteuria}, which has several stages; the final stage is what is
actually counted, and as it is an endospore, it is likely fairly inert in
the host.
Rather than assuming an exponentially distributed waiting time in the
replicating stage, I assume a fixed delay $\tau$, that is the duration
of the replicating stage.
The fourth model is then
\begin{align}
(4a) \frac{dP_i(t)}{dt} &= \epsilon_P a_P E(t) P_i(t) - \epsilon_P a_P
                          E(t-\tau) P_i(t-\tau), \\
(4b) \frac{dP_m(t)}{dt} &= \epsilon_P a_P E(t-\tau) P_i(t-\tau).
\end{align}
The fifth model is slightly more complicated, because we have to take
into consideration the mortality of the replicating stage.
Since the mortality rate is $m$, the probability that an replicating
stage parasite survives $\tau$ time units and matures is $e^{-m
  \tau}$, so the model of parasite growth and development is:
\begin{align}
(5a) \frac{dP_i(t)}{dt} &= \epsilon_P a_P E(t) P_i(t) - e^{-m \tau}\epsilon_P a_P
                          E(t-\tau) P_i(t-\tau), \\
(5b) \frac{dP_m(t)}{dt} &= e^{-m \tau} \epsilon_P a_P E(t-\tau) P_i(t-\tau).
\end{align}
The sixth model again assumes logistic growth with a carrying capacity
determined by size.
I assume that both replicating and non-replicating stages contribute
to the carrying capacity.
\begin{align}
(6a) \frac{dP_i(t)}{dt} &= \epsilon_P a_P E(t) P_i(t) \left(1 -
                          \frac{P_i(t)+P_m(t)}{k_P W(t)}\right) - \epsilon_P a_P E(t-\tau) P_i(t-\tau) \left(1 -
                          \frac{P_i(t-\tau)+P_m(t-\tau)}{k_P
                          W(t-\tau)}\right) \\
(6b) \frac{dP_m(t)}{dt} &= \epsilon_P a_P E(t-\tau) P_i(t-\tau) \left(1 -
                          \frac{P_i(t-\tau)+P_m(t-\tau)}{k_P W(t-\tau)}\right).
\end{align}

\subsection*{Models of exploitation of soma}
Here I will assume that \emph{Pasteuria} exploits somatic mass, so there will be a negative term in the $\frac{dW}{dt}$ term.
Otherwise, the size possible forms for the growth equation parallel those in the model of reserve exploitation:
\begin{align}
(7) \frac{dP}{dt} &= \epsilon_P a_P W P, \\
(8) \frac{dP}{dt} &= \epsilon_P a_P W P - m P, \\
(9) \frac{dP}{dt} &= \epsilon_P a_P W P \left(1 - \frac{P}{k_P W}\right).
(10a) \frac{dP_i(t)}{dt} &= \epsilon_P a_P W(t) P_i(t) - \epsilon_P a_P
                          W(t-\tau) P_i(t-\tau), \\
(10b) \frac{dP_m(t)}{dt} &= \epsilon_P a_P W(t-\tau) P_i(t-\tau).
(11a) \frac{dP_i(t)}{dt} &= \epsilon_P a_P W(t) P_i(t) - e^{-m \tau}\epsilon_P a_P
                          W(t-\tau) P_i(t-\tau), \\
(11b) \frac{dP_m(t)}{dt} &= e^{-m \tau} \epsilon_P a_P W(t-\tau) P_i(t-\tau).
(12a) \frac{dP_i(t)}{dt} &= \epsilon_P a_P W(t) P_i(t) \left(1 -
                          \frac{P_i(t)+P_m(t)}{k_P W(t)}\right) - \epsilon_P a_P W(t-\tau) P_i(t-\tau) \left(1 -
                          \frac{P_i(t-\tau)+P_m(t-\tau)}{k_P
                          W(t-\tau)}\right) \\
(12b) \frac{dP_m(t)}{dt} &= \epsilon_P a_P W(t-\tau) P_i(t-\tau) \left(1 -
                          \frac{P_i(t-\tau)+P_m(t-\tau)}{k_P W(t-\tau)}\right).
\end{align}

\begin{comment}
\subsection*{Models of exploitation of growth allocation}
These models are slightly more complicated, and fall into two classes.
In the first, \emph{Pasteuria} diverts a constant fraction, $\phi$ of growth allocation towards itself.
$\phi$ is assumed to be constant and independent of parasite population size.
This reduces growth allocation from $\kappa p_C$ to $(1-\phi) \kappa p_C$.
We consider three possible parasite growth functions:
\begin{align}
(11) \frac{dP}{dt} &= \epsilon_P \phi \kappa p_C, \\
(12) \frac{dP}{dt} &= \epsilon_P \phi \kappa p_C - m P, \\
(13) \frac{dP}{dt} &= \epsilon_P \phi \kappa p_C \left(1 - \frac{P}{k_P W}\right).
\end{align}

The second class of models assumes that the fraction of growth allocation that is diverted towards the parasite is dependent on the parasite abundance.
Specifically, we assume that the fraction diverted is $\phi \frac{P}{h_P + P}$, so that the fraction diverted asymptotically approaches $\phi$ and $P$ approaches infinity.
We consider the same three model variants as before:
\begin{align}
(14) \frac{dP}{dt} &= \epsilon_P \phi \frac{P}{h_P + P} \kappa p_C, \\
(15) \frac{dP}{dt} &= \epsilon_P \phi \frac{P}{h_P + P} \kappa p_C - m P, \\
(16) \frac{dP}{dt} &= \epsilon_P \phi \frac{P}{h_P + P} \kappa p_C \left(1 - \frac{P}{k_P W}\right).
\end{align}

\subsection*{Fitting parasite growth data alone}
Given the utility of fitting the body size data alone, before I attempt to fit both the body size and parasite spore data simultaneously, it makes sense to see if there is anything to be learned from fitting the spore data alone.
In this case, I will assume that $E$ or $W$ is specified, and fit the competing parasite models to the spore data alone.
This will give me some information about how difficult the spore data is going to be to fit on its own, as well as providing some ballpark estimates for the different parameters.

If I look at the outputs of $E$ and $W$ from the best-fitting model of infected growth (see Fig. \ref{fig:inf-length-2}), I can get reasonable estimates for $E$ and $W$.
In particular, $E$ is bounded between about 3e-5 and 4e-5, whereas $W$ obviously changes over time.
To fit parasite data only, I either assumed a constant reserve $E=3\times10^{-5}$ or a growth somatic mass $W$, where mass was determined at each time point by a cubic regression of observed growth on age.
I did not carry out a full fitting study, as I only ran a single optimization from a single set of starting points.
The purpose was just to see whether some of the model fits would immediately give confidence that the algorithm had some chance of actually fitting the data.
The results (Fig. \ref{fig:parasite-only}) are fairly informative in that regard.
The Type I functional response is, essentially, a non-starter. The fits were horrible for both resource models.

<<'parasite-only', fig.height=3, fig.width=4.5, units='in', res=300, fig.cap="Fits of the parasite growth trajectory only, for 8 different models. The left-hand panel shows the best fits of models where the parasite exploits a constant reserve $E$; the right-hand panel shows the best fits of models where the parasite exploits somatic tissue $W$ (where the amount of somatic mass was set by the mean of a cubic regression on the actual observed parasite growth. For each parasite resource, we fit four models: a model with an unstructured parasite population with a Type I functional response, a model with an unstructured parasite population with resource-dependent and host size-dependent logistic growth (growth rate is determined by resources, carrying capacity is determined by host size), and structured population models of the same (immature and mature spores, where mature spores contribute to carrying capacity but do not reproduce)." >>=

## functions for the fitting spore data only
source("Spore_trajectory_matching.R")

## data
x <- read.csv("Cat_data/all_data.csv") %>% as.data.frame
x2 <- subset(x, infected==1)
data <- x2[,c("day.of.assay","length..mm.","Spore.per.animal")]
colnames(data) <- c("age","length","spores")
## how to deal with 0s?
data$spores[is.na(data$spores)] <- 0

## Model for infected host growth that can be used for W parasites
lmm2 <- with(data, lm(length~age+I(age^2)))
lmm3 <- with(data, lm(length~age+I(age^2)+I(age^3)))
anova(lmm2, lmm3) ## reveals that the third-order polynomial gives a much better fit

## Plot the best fits
par(mfrow=c(1,2), mar=c(2.5,2.5,0.5,0.5), oma=rep(1,4))
plot(data$age, data$spores, ylim=c(0, max(data$spores)), xlab='', ylab='')
mtext(side=1, outer=T, line=0, "Age")
mtext(side=2, outer=T, line=0, "Spores")
legend(x="topleft", fill=1:4, c("Type I", "Stage-str. Type I", "Logistic", "Stage-str. Logistic"), bty='n')

## Type I E exploiter
model <- "parasite_only_E_TypeI"
dyn.load(paste0(model,.Platform$dynlib.ext))
## test
optimizer(estpars=c(aP=1e-8, eP=1e10, P0=10, Pobs=100),
          fixpars=c(E=3e-5),
          parorder=c("E","aP","eP","P0","Pobs"),
          transform=rep('log',4),
          data,
          model=model,
          eval.only=TRUE,
          method="Nelder-Mead")
## fit
opt1 <- optimizer(estpars=c(aP=1e-8, eP=1e10, P0=10, Pobs=100),
                  fixpars=c(E=3e-5),
                  parorder=c("E","aP","eP","P0","Pobs"),
                  transform=rep('log',4),
                  data,
                  model=model,
                  eval.only=FALSE,
                  method="Nelder-Mead")
pars <- c(E=3e-5, opt1$params)
pars <- pars[match(c("E","aP","eP","P0","Pobs"),names(pars))]
ode(y=opt1$params["P0"],
    times=seq(0,35,0.1),
    func="derivs",
    parms=pars,
    dllname=model,
    initfunc="initmod") -> out
lines(out[,1], out[,2], col=1)


## stage-structured Type I E exploiter
model <- "parasite_only_E_TypeI_delay"
dyn.load(paste0(model,.Platform$dynlib.ext))
## test
optimizer(estpars=c(aP=1e-8, eP=1e10, tau=10, P0=10, Pobs=100),
          fixpars=c(E=3e-5),
          parorder=c("E","aP","eP","tau","P0","Pobs"),
          transform=rep('log',5),
          data,
          model=model,
          eval.only=TRUE,
          method="Nelder-Mead")
## fit
opt2 <- optimizer(estpars=c(aP=1e-8, eP=1e10, tau=10, P0=10, Pobs=100),
                  fixpars=c(E=3e-5),
                  parorder=c("E","aP","eP","tau","P0","Pobs"),
                  transform=rep('log',5),
                  data,
                  model=model,
                  eval.only=FALSE,
                  method="Nelder-Mead")
pars <- c(E=3e-5, opt2$params)
pars <- pars[match(c("E","aP","eP","tau","P0","Pobs"),names(pars))]
dede(y=c(Pi=opt2$params["P0"],Pm=0),
    times=seq(0,35,0.1),
    func="derivs",
    parms=pars,
    dllname=model,
    initfunc="initmod") -> out
lines(out[,1], out[,3], col=2)


## Logistic E exploiter
model <- "parasite_only_E_logistic"
dyn.load(paste0(model,.Platform$dynlib.ext))
## test
optimizer(estpars=c(aP=1e-8, eP=1e10, kP=500000, P0=10, Pobs=100),
          fixpars=c(E=3e-5),
          parorder=c("E","aP","eP","kP","P0","Pobs"),
          transform=rep('log',5),
          data,
          model=model,
          eval.only=TRUE,
          method="Nelder-Mead")
## fit
opt3 <- optimizer(estpars=c(aP=1e-8, eP=1e10, kP=500000, P0=10, Pobs=100),
                  fixpars=c(E=3e-5),
                  parorder=c("E","aP","eP","kP","P0","Pobs"),
                  transform=rep('log',5),
                  data,
                  model=model,
                  eval.only=FALSE,
                  method="Nelder-Mead")
pars <- c(E=3e-5, opt3$params)
pars <- pars[match(c("E","aP","eP","kP","P0","Pobs"),names(pars))]
ode(y=opt3$params["P0"],
    times=seq(0,35,0.1),
    func="derivs",
    parms=pars,
    dllname=model,
    initfunc="initmod") -> out
lines(out, col=3)

## Stage-structured logistic E exploiter
model <- "parasite_only_E_logistic_delay"
dyn.load(paste0(model,.Platform$dynlib.ext))
## test
optimizer(estpars=c(aP=1e-8, eP=1e10, kP=5000000, tau=10, P0=10, Pobs=100),
          fixpars=c(E=3e-5),
          parorder=c("E","aP","eP","kP","tau","P0","Pobs"),
          transform=rep('log',6),
          data,
          model=model,
          eval.only=TRUE,
          method="Nelder-Mead")
## fit
opt4 <- optimizer(estpars=c(aP=1e-8, eP=1e10, kP=5000000, tau=10, P0=10, Pobs=100),
          fixpars=c(E=3e-5),
          parorder=c("E","aP","eP","kP","tau","P0","Pobs"),
          transform=rep('log',6),
          data,
          model=model,
          eval.only=FALSE,
          method="Nelder-Mead")
pars <- c(E=3e-5, opt4$params)
pars <- pars[match(c("E","aP","eP","kP","tau","P0","Pobs"),names(pars))]
dede(y=c(Pi=opt4$params["P0"],Pm=0),
    times=seq(0,35,0.1),
    func="derivs",
    parms=pars,
    dllname=model,
    initfunc="initmod") -> out
lines(out[,1], out[,3], col=4)

#################################################################3
####################### W EXPLOITER ######################
#################################################################3
## Plot the best fits
plot(data$age, data$spores, ylim=c(0, max(data$spores)), xlab='', ylab='')
mtext(side=1, outer=T, line=0, "Age")
mtext(side=2, outer=T, line=0, "Spores")

## Type I W exploiter
model <- "parasite_only_W_TypeI"
dyn.load(paste0(model,.Platform$dynlib.ext))
## test
optimizer(estpars=c(aP=1e-8, eP=1e10, P0=10, Pobs=100),
          fixpars=c(),
          parorder=c("aP","eP","P0","Pobs"),
          transform=rep('log',4),
          data,
          model=model,
          eval.only=TRUE,
          method="Nelder-Mead")
## fit
opt5 <- optimizer(estpars=c(aP=1e-8, eP=1e10, P0=10, Pobs=100),
                  fixpars=c(),
                  parorder=c("aP","eP","P0","Pobs"),
                  transform=rep('log',4),
                  data,
                  model=model,
                  eval.only=FALSE,
                  method="Nelder-Mead")
pars <- opt5$params
pars <- pars[match(c("aP","eP","P0","Pobs"),names(pars))]
ode(y=opt5$params["P0"],
    times=seq(0,35,0.1),
    func="derivs",
    parms=pars,
    dllname=model,
    initfunc="initmod") -> out
lines(out[,1], out[,2], col=1)


## stage-structured Type I E exploiter
model <- "parasite_only_W_TypeI_delay"
dyn.load(paste0(model,.Platform$dynlib.ext))
## test
optimizer(estpars=c(aP=1e-8, eP=1e10, tau=10, P0=10, Pobs=100),
          fixpars=c(),
          parorder=c("aP","eP","tau","P0","Pobs"),
          transform=rep('log',5),
          data,
          model=model,
          eval.only=TRUE,
          method="Nelder-Mead")
## fit
opt6 <- optimizer(estpars=c(aP=1e-8, eP=1e10, tau=10, P0=10, Pobs=100),
                  fixpars=c(),
                  parorder=c("aP","eP","tau","P0","Pobs"),
                  transform=rep('log',5),
                  data,
                  model=model,
                  eval.only=FALSE,
                  method="Nelder-Mead")
pars <- opt6$params
pars <- pars[match(c("aP","eP","tau","P0","Pobs"),names(pars))]
dede(y=c(Pi=opt6$params["P0"],Pm=0),
    times=seq(0,35,0.1),
    func="derivs",
    parms=pars,
    dllname=model,
    initfunc="initmod") -> out
lines(out[,1], out[,3], col=2)

## Logistic W exploiter
model <- "parasite_only_W_logistic"
dyn.load(paste0(model,.Platform$dynlib.ext))
## test
optimizer(estpars=c(aP=1e-8, eP=1e10, kP=500000, P0=10, Pobs=100),
          fixpars=c(),
          parorder=c("aP","eP","kP","P0","Pobs"),
          transform=rep('log',5),
          data,
          model=model,
          eval.only=TRUE,
          method="Nelder-Mead")
## fit
opt7 <- optimizer(estpars=c(aP=1e-8, eP=1e10, kP=500000, P0=10, Pobs=100),
                  fixpars=c(),
                  parorder=c("aP","eP","kP","P0","Pobs"),
                  transform=rep('log',5),
                  data,
                  model=model,
                  eval.only=FALSE,
                  method="Nelder-Mead")
pars <- opt7$params
pars <- pars[match(c("aP","eP","kP","P0","Pobs"),names(pars))]
ode(y=opt7$params["P0"],
    times=seq(0,35,0.1),
    func="derivs",
    parms=pars,
    dllname=model,
    initfunc="initmod") -> out
lines(out, col=3)

## Stage-structured logistic E exploiter
model <- "parasite_only_W_logistic_delay"
dyn.load(paste0(model,.Platform$dynlib.ext))
## test
optimizer(estpars=c(aP=1e-8, eP=1e10, kP=5000000, tau=10, P0=10, Pobs=100),
          fixpars=c(),
          parorder=c("aP","eP","kP","tau","P0","Pobs"),
          transform=rep('log',6),
          data,
          model=model,
          eval.only=TRUE,
          method="Nelder-Mead")
## fit
opt8 <- optimizer(estpars=c(aP=1e-8, eP=1e10, kP=5000000, tau=10, P0=10, Pobs=100),
          fixpars=c(),
          parorder=c("aP","eP","kP","tau","P0","Pobs"),
          transform=rep('log',6),
          data,
          model=model,
          eval.only=FALSE,
          method="Nelder-Mead")
pars <- opt8$params
pars <- pars[match(c("aP","eP","kP","tau","P0","Pobs"),names(pars))]
dede(y=c(Pi=opt8$params["P0"],Pm=0),
    times=seq(0,35,0.1),
    func="derivs",
    parms=pars,
    dllname=model,
    initfunc="initmod") -> out
lines(out[,1], out[,3], col=4)


@

\end{comment}


\subsection*{Details of the fitting procedure}
In addition to estimating the parameters of the parasite growth equation (between two and four parameters), we also estimated the somatic maintenance rate of infected animals $k_m$ (based on our findings above), and a measurement error parameter.
The initial abundance of parasites is not a known quantity, as the hosts were exposed to a constant dose of parasite for a known duration, but a single spore can initiate infection in this system.
However, initial value parameters are notoriously difficult to
estimate, and can be difficult to constrain.
Thus I chose to assume an initial abundance of 100 replicating
parasites for each model.

Since the parasite population is growing, assuming normally distributed observation error with constant variance is potentially problematic.
Instead, we assumed that observation error was negative binomially distributed, with mean, $\mu$, given by the model, and the dispersion parameter, $s$, being estimated.
The variance of the negative binomial distribution is $\mu + \mu^2/s$, so that variance increases with the mean, a feature observed in the spore count data.

We also had to make assumptions about other physiological parameters.
We held all of the DEB parameters at the values estimated from the uninfected animals' growth and reproduction data except for the somatic maintenance rate and the allocation to growth, $\kappa$.
Because \emph{Pasteuria} is a castrating parasite, it is clear that $\kappa$ eventually becomes equal to one, but as none of the \emph{Daphnia} ever reproduced, it is very difficult to estimate \emph{when} $\kappa$ changes from its uninfected value to one.
For simplicity, therefore, we simply assumed that $\kappa = 1$ from birth.
From our preliminary analysis, we know that parasites must adjust
other physiological parameters as well.
We allowed the somatic maintenance rate $k_m$ to be estimated as well
to provide the additional flexibility needed to fit the growth data.

Finally, we assumed that ingestion followed the best-fitting model of infected ingestion estimated from the foraging rate data.
Note that this is not the same as the model used above to fit the growth data because it assumes spore-dependent feeding - see Fig. 4 in "Notes\_feeding\_model.pdf" to see the fitting results for this model.
For the structured population models, we assumed that the feeding rate
was dependent on the number of non-replicating parasites (which
represent the stage that is actually counted).

\subsection*{Results}

<<echo=FALSE>>=
library(magrittr)


models <- c("deb_parasite_E_TypeI",
            "deb_parasite_E_TypeI_m",
            "deb_parasite_E_logistic",
            "deb_parasite_E_TypeI_delay",
            "deb_parasite_E_TypeI_delay_2",
            "deb_parasite_E_TypeI_delay_3",
            "deb_parasite_E_TypeI_delay_m",
            "deb_parasite_E_TypeI_delay_m_2",
            "deb_parasite_E_TypeI_delay_m_3",
            "deb_parasite_E_logistic_delay",
            "deb_parasite_E_logistic_delay_2",
            "deb_parasite_E_logistic_delay_3",
            "deb_parasite_W_TypeI",
            "deb_parasite_W_TypeI_m",
            "deb_parasite_W_logistic",
            "deb_parasite_W_TypeI_delay",
            "deb_parasite_W_TypeI_delay_2",
            "deb_parasite_W_TypeI_delay_3",
            "deb_parasite_W_TypeI_delay_m",
            "deb_parasite_W_TypeI_delay_m_2",
            "deb_parasite_W_TypeI_delay_m_3",
            "deb_parasite_W_logistic_delay",
            "deb_parasite_W_logistic_delay_2",
            "deb_parasite_W_logistic_delay_3")


estimates <- vector(mode='list', length=length(models))
for (i in 1:length(models)) {
  x <- readRDS(paste0("TM_parameter_estimates_",models[i],".RDS"))
  x %>% unlist %>% matrix(., ncol=length(x[[1]]$params)+2, byrow=TRUE) %>% as.data.frame -> y
  colnames(y) <- c(names(x[[1]]$params), 'lik', 'conv')
  y <- subset(y, conv==0)
  y1 <- y[order(y$lik),]
  k <- length(x[[1]]$params)
  n <- 138 ## number of datapoints
  y1 <- mutate(y1, aic=2*length(x[[1]]$params) + 2*y1$lik, aicc=aic+2*k*(k+1)/(n-k-1))
  estimates[[i]] <- y1
}

source("Growth_reproduction_trajectory_matching_infecteds.R")

x <- read.csv("Cat_data/all_data.csv") %>% as.data.frame
x2 <- subset(x, infected==1)
data <- x2[,c("day.of.assay","length..mm.","Spore.per.animal")]
colnames(data) <- c("age","length","spores")
## how to deal with 0s?
data$spores[is.na(data$spores)] <- 0
## idiot check: make sure likelihoods agree (seems like maybe they don't)

for (i in 1:length(models)) {
    model <- mod <- models[[i]]
    if (length(grep("2", model))==1 || length(grep("3",model))==1)
        mod <- strsplit(model, "_")[[1]][-(strsplit(model, "_")[[1]] %>% length)] %>% paste(., collapse="_")
    #system(paste0("R CMD SHLIB ", mod, ".c"))
    dyn.load(paste0(mod,.Platform$dynlib.ext))

    if (length(grep("_2",model))==0 & length(grep("_3",model))==0)
        fixpars <- c(rho=0.152, K=1, v=10, F0=1e6/30, Lobs=0.0102, P0=100)
    else if (length(grep("_2",model))==1)
        fixpars <- c(K=1, km=0.073, v=10, F0=1e6/30, Lobs=0.0102, P0=100)
    else
        fixpars <- c(K=1, v=10, F0=1e6/30, Lobs=0.0102, P0=100)

    estpars <- estimates[[i]][1,1:(ncol(estimates[[i]])-4)] %>% unlist
    parorder <- c(c("rho","K","km","v","F0","Lobs"),names(estpars))
    parorder <- parorder[-which(duplicated(parorder))]
    pars <- c(fixpars, estpars)
    pars <- pars[match(parorder, names(pars))]
    pars <- c(pars[1:(length(pars)-1)],P0=100,pars[length(pars)])

    eventdat <- data.frame(var="F",
                           time=1:35,
                           value=unname(pars["F0"]),
                           method=rep(c(rep("add",4),"rep"),max(data$age)/5))

    if (length(grep("delay", model))==1) { ## delay model
        y0 <- c(F=unname(pars["F0"]),
                E=0,
                W=unname(5.39e-5/(1+pars["rho"]/pars["v"])),
                Pi=unname(pars["P0"]),
                Pm=0)
        y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])
        ## Simulate the system
        try(dede(y0,
                times=seq(0,35,0.1),
                func="derivs",
                parms=pars,
                dllname=mod,
                initfunc="initmod",
                 events=list(data=eventdat))) -> out
        pdf(file=paste0("model",i,".pdf"))
        plot(out[,c('time','Pm')], type='l', main=paste('model', i), ylim=c(0, max(c(out[,'Pm'],data[,'spores']))))
        points(data[,'age'], data[,'spores'])
        dev.off()
    }
    else {
        y0 <- c(F=unname(pars["F0"]),
                E=0,
                W=unname(5.39e-5/(1+pars["rho"]/pars["v"])),
                P=unname(pars["P0"]))
        y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])
        ## Simulate the system
        try(ode(y0,
                times=seq(0,35,0.1),
                func="derivs",
                parms=pars,
                dllname=mod,
                initfunc="initmod",
                events=list(data=eventdat))) -> out
        pdf(file=paste0("model",i,".pdf"))
        plot(out[,c('time','P')], type='l', main=paste("model", i))
        points(data[,'age'], data[,'spores'])
        dev.off()
    }
    as.data.frame(out[round(out[,'time'],1)%in%data$age,]) -> pred

    ## compute the observed weight as Wobs = W + E and compute the observed length prediction as Wobs=xi*Lobs^q; (Wobs/xi)^(1/q)=Lobs
    xi <- 1.8e-3; q <- 3;
    mutate(pred, Wobs=W+E, Lobs=(Wobs/xi)^(1/q)) -> pred

    ## compute the probability of observing the data, given the prediction
    if (length(grep("delay", model))==1) {
        sapply(unique(data$age),
               function(d)
                   c(dnorm(x=data$length[data$age==d],
                           mean=pred$Lobs[round(pred$time)==d],
                           sd=pars["Lobs"],
                           log=TRUE) %>% sum,
                     dnbinom(x=data$spores[data$age==d],
                             mu=pred$Pm[round(pred$time)==d],
                             size=pars["Pobs"],
                             log=TRUE) %>% sum
                     ) %>% sum
               ) %>% sum -> lik
    }
    else {
        sapply(unique(data$age),
               function(d)
                   c(dnorm(x=data$length[data$age==d],
                           mean=pred$Lobs[round(pred$time)==d],
                           sd=pars["Lobs"],
                           log=TRUE) %>% sum,
                     dnbinom(x=data$spores[data$age==d],
                             mu=pred$P[round(pred$time)==d],
                             size=pars["Pobs"],
                             log=TRUE) %>% sum
                     ) %>% sum
               ) %>% sum -> lik }
    ## There were a few datasets (4, 5, 8, 20, 21, and 23) where there was an error calculating the likelihood (when extracting model predictions at the ages where there is observed data, errors in comparing sometimes caused some ages to be dropped from the predictions, and the likelihood of these datapoints was automatically set to 0, giving an advantage to those datasets). So, for these datasets, we used the second set of parameter values, rather than the first, since the likelihoods calculated for the second-best parameter set were always correct.
    if (abs(lik+estimates[[i]][1,'lik']) > 1e-9) {
        print(i)
        estimates[[i]] <- estimates[[i]][-1,]
    }
}





@

The table shows the results of the fitting of the different models.
You can see that \textbf{the best-supported model has a stage-structured parasite exploiting somatic tissue with a carrying capacity determined by host mass}.
The parameter values are probably not worth taking very seriously, but they are interesting in what they indicate.
In particular, the best-fitting somatic maintenance rate $k_m$ is essentially zero.
This is actually not that surprising, given what we saw earlier, that it is very difficult to fit the growth trajectory.
The other thing to notice is that the negative binomial measurement error estimates $P_{err}$ are always very small, which greatly inflates the variance.
However, the mean trajectories for growth of infected animals and spore production actually look pretty good (Fig. \ref{fig:best-fit}).

<<>>=
ord <- lapply(estimates, function(l) l$aicc[1]) %>% unlist %>% order
tabl <- array(NA, dim=c(length(ord),7))
colnames(tabl) <- c("rho","km","aP","eP","kP","tau","Pobs")

for (i in 1:length(ord)) {
    j <- ord[i]
    whichcols <- match(colnames(tabl),colnames(estimates[[j]]))
    for (k in 1:length(whichcols)) {
        if (is.na(whichcols[k])) tabl[i,k] <- "--"
        else tabl[i,k] <- signif(estimates[[j]][1,whichcols[k]],3)
    }
}
modelnames <- c("Type I E exploiter",
                "Type I E exploiter w/mortality",
                "Logistic E exploiter",
                "Structured Type I E exploiter",
                "Structured Type I E exploiter",
                "Structured Type I E exploiter",
                "Structured Type I E exploiter w/mortality",
                "Structured Type I E exploiter w/mortality",
                "Structured Type I E exploiter w/mortality",
                "Structured logistic I E exploiter",
                "Structured logistic I E exploiter",
                "Structured logistic I E exploiter",
                "Type I E exploiter",
                "Type I E exploiter w/mortality",
                "Logistic E exploiter",
                "Structured Type I E exploiter",
                "Structured Type I E exploiter",
                "Structured Type I E exploiter",
                "Structured Type I E exploiter w/mortality",
                "Structured Type I E exploiter w/mortality",
                "Structured Type I E exploiter w/mortality",
                "Structured logistic I E exploiter",
                "Structured logistic I E exploiter",
                "Structured logistic I E exploiter")

tabl <- cbind(modelnames[ord], tabl)
aics <- lapply(estimates, function(l) l$aic[1]) %>% unlist
tabl <- cbind(tabl, round(aics[ord]))

colnames(tabl) <- c("model","$\\rho$","$k_m$","$a_P$","$e_P$","$k_P$","$\\tau$","$\\sigma_P$","AIC")
print(xtable(tabl), include.rownames=FALSE)

@


<<best-fit, fig.width=2.5, units='in', res=300, fig.cap="Infected animal growth and spore production for the two best fitting models. You can see that the models predict essentially identical growth and mature spore production.">>=

model <- mod <- models[[ord[1]]]
if (length(grep("2", model))==1 || length(grep("3",model))==1)
    mod <- strsplit(model, "_")[[1]][-(strsplit(model, "_")[[1]] %>% length)] %>% paste(., collapse="_")
dyn.load(paste0(mod,.Platform$dynlib.ext))
fixpars <- c(K=1, v=10, F0=1e6/30, Lobs=0.0102, P0=100)

estpars <- estimates[[ord[1]]][1,1:(ncol(estimates[[ord[1]]])-4)] %>% unlist
parorder <- c(c("rho","K","km","v","F0","Lobs"),names(estpars))
parorder <- parorder[-which(duplicated(parorder))]
pars <- c(fixpars, estpars)
pars <- pars[match(parorder, names(pars))]
pars <- c(pars[1:(length(pars)-1)],P0=100,pars[length(pars)])

eventdat <- data.frame(var="F",
                       time=1:35,
                       value=unname(pars["F0"]),
                       method=rep(c(rep("add",4),"rep"),max(data$age)/5))

y0 <- c(F=unname(pars["F0"]),
        E=0,
        W=unname(5.39e-5/(1+pars["rho"]/pars["v"])),
        Pi=unname(pars["P0"]),
        Pm=0)
y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])
## Simulate the system
try(dede(y0,
         times=seq(0,35,0.1),
         func="derivs",
         parms=pars,
         dllname=mod,
         initfunc="initmod",
         events=list(data=eventdat))) %>% as.data.frame -> out
xi <- 1.8e-3; q <- 3;
mutate(out, Wobs=W+E, Lobs=(Wobs/xi)^(1/q)) -> pred



model <- mod <- models[[ord[2]]]
if (length(grep("2", model))==1 || length(grep("3",model))==1)
    mod <- strsplit(model, "_")[[1]][-(strsplit(model, "_")[[1]] %>% length)] %>% paste(., collapse="_")
dyn.load(paste0(mod,.Platform$dynlib.ext))

fixpars <- c(K=1, v=10, F0=1e6/30, Lobs=0.0102, P0=100)

estpars <- estimates[[ord[2]]][1,1:(ncol(estimates[[ord[2]]])-4)] %>% unlist
parorder <- c(c("rho","K","km","v","F0","Lobs"),names(estpars))
parorder <- parorder[-which(duplicated(parorder))]
pars <- c(fixpars, estpars)
pars <- pars[match(parorder, names(pars))]
pars <- c(pars[1:(length(pars)-1)],P0=100,pars[length(pars)])

eventdat <- data.frame(var="F",
                       time=1:35,
                       value=unname(pars["F0"]),
                       method=rep(c(rep("add",4),"rep"),max(data$age)/5))

y0 <- c(F=unname(pars["F0"]),
        E=0,
        W=unname(5.39e-5/(1+pars["rho"]/pars["v"])),
        Pi=unname(pars["P0"]),
        Pm=0)
y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])
## Simulate the system
try(dede(y0,
         times=seq(0,35,0.1),
         func="derivs",
         parms=pars,
         dllname=mod,
         initfunc="initmod",
         events=list(data=eventdat))) %>% as.data.frame -> out2
xi <- 1.8e-3; q <- 3;
mutate(out2, Wobs=W+E, Lobs=(Wobs/xi)^(1/q)) -> pred2

par(mfcol=c(2,1), mar=c(1.5, 4.5, 0.5, 0.5), oma=c(3, 0, 0, 0), las=1)
plot(data$age, data$length, xlab="", ylab="Length (mm)", xaxt='n')
axis(1, tick=TRUE, label=FALSE)
lines(out[,'time'], (out[,'W']/xi)^(1/q), type='l', lwd=2)
lines(out2[,'time'], (out2[,'W']/xi)^(1/q), type='l', lwd=2, lty=2, col=gray(0.5))

plot(data$age, data$spores/1e5, xlab="", ylab=expression(10^5~~"Mature spores"))
lines(pred$time, pred$Pm/1e5, type='l', lwd=2)
lines(pred2$time, pred2$Pm/1e5, type='l', lwd=2, lty=2, col=gray(0.5))
mtext(side=1, outer=T, line=1.5, 'Age')
legend(x='topleft', lty=c(1,2), lwd=2, col=c(1,gray(0.5)), c("E exploiter", "W exploiter"), bty='n')
@


<<eval=FALSE>>=
data = read.csv("Cat_data/all_data.csv")
data <- data[,c(1,3,4,11,13,14)]
colnames(data) <- c("Age","Infected","Length (mm)", "Clearance rate (cells/time)", "Cumulative offspring", "Pasteuria endospores")
data[,5] = as.character(data[,5])
data[as.character(data[,5])=="n/a",5] = 0
data[,5] <- as.numeric(data[,5])
data[is.na(data[,6]),6] <- 0
dat <- gather(data, key=Measure, value=Value, 3:6)

png(file="~/Desktop/All_data_one_figure.png", width=2000, height=1800, units='px', res=300)
ggplot(dat, aes(x=Age, y=Value, colour=factor(Infected))) +
    geom_point() +
        stat_smooth() +
        facet_wrap(~Measure, scales="free_y") +
            theme_bw() +
                scale_colour_manual(values=c("black","red"), name="", labels=c("Uninfected","Infected"))
dev.off()


@

<<>>=
source("Growth_trajectory_matching_infecteds.R")
model <- "deb_parasite_growth_only"
#dyn.load(paste0(model,'.dll')) ## PC
dyn.load(paste0(model,'.so')) ## Mac

x <- read.csv("Cat_data/all_data.csv") %>% as.data.frame
x2 <- subset(x, infected==1)
data <- x2[,c("day.of.assay","length..mm.","Spore.per.animal")]
colnames(data) <- c("age","length","spores")
## how to deal with 0s?
data$spores[is.na(data$spores)] <- 0

## parameters fixed at the uninfected data values
fixpars <- c(rho=0.152, km=0.073, v=10, F0=1e6/30, Lobs=0.0102)

## estimated parameters for this parasite model
estpars <- c(K=0.680)

## unconstrained scale transformation
transform <- 'logit'

## ensure that the parameters are in the correct order for the model function
pars <- c(estpars, fixpars)
parorder <- c("rho","K","km","v","F0","Lobs")
pars[match(parorder, names(pars))] -> pars

## Generic set of food addition events
eventdat <- data.frame(var="F",
                       time=1:35,
                       value=unname(pars["F0"]),
                       method=rep(c(rep("add",4),"rep"),max(data$age)/5))

## Initial condition: assuming that E/W = rho/v and E+W=ER, then W
## + W*rho/v = ER, W(1+rho/v)=ER, W=ER/(1+rho/v)
y0 <- c(F=unname(pars["F0"]),
        E=0,
        W=unname(5.39e-5/(1+pars["rho"]/pars["v"])))
y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])
## Simulate the system
try(ode(y0,
        times=seq(0,35,0.1),
        func="derivs",
        parms=pars,
        dllname=model,
        initfunc="initmod",
        events=list(data=eventdat))) %>% as.data.frame -> out0
mutate(out0, Lobs=(W/0.0018)^(1/3)) -> out0

## one dimensional optimization
Kopt <- optimize(f=tm_obj_2, interval=c(0,1), tol=1e-5, data=data, fixpars=fixpars, parorder=parorder, model=model)
## Kopt is maximized at K=1
pars["K"] <- Kopt$minimum
y0 <- c(F=unname(pars["F0"]),
        E=0,
        W=unname(5.39e-5/(1+pars["rho"]/pars["v"])))
y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])
## Simulate the system
try(ode(y0,
        times=seq(0,35,0.1),
        func="derivs",
        parms=pars,
        dllname=model,
        initfunc="initmod",
        events=list(data=eventdat))) %>% as.data.frame -> out1
mutate(out1, Lobs=(W/0.0018)^(1/3)) -> out1





with(mutate(as.data.frame(out), Wobs=W+E, Lobs=(Wobs/xi)^(1/q)), plot(time, Lobs, type='l', ylim=c(0.3,2), xlab="Age", ylab="Length (mm)"))
with(data, points(age, length))

@

\end{document}
