
## TESTING
source("Growth_reproduction_trajectory_matching_infecteds_model_3.R")

x <- read.csv("Cat_data/all_data.csv") %>% as.data.frame
x2 <- subset(x, infected==1)
data <- x2[,c("day.of.assay","length..mm.","Spore.per.animal")]
colnames(data) <- c("age","length","spores")
## how to deal with 0s?
data$spores[is.na(data$spores)] <- 0

## parameters fixed at the uninfected data values
fixpars <- c(rho=0.152, K=1, km=0.073, v=10, F0=1e6/30, Lobs=0.0102)
## unconstrained scale transformation
transform <- rep('log',4)
parorder <- c("rho","K","km","v","F0","Lobs","aP","eP","Pobs")

## Estimate the parameters
box <- cbind(lower=c(aP=1e-10, eP=1e6, Pobs=1e2),
             upper=c(aP=1e-4, eP=1e9, Pobs=1e4))
sobolDesign(lower=box[,'lower'],
            upper=box[,'upper'],
            nseq=300) %>%
                apply(., 1, as.list) %>%
                    lapply(., unlist) -> guesses

estpars <- c(aP=1e-10, eP=1e9, Pobs=100)
pars <- c(estpars, fixpars)
pars[match(parorder, names(pars))] -> pars
## Generic set of food addition events
eventdat <- data.frame(var="F",
                       time=1:35,
                       value=unname(pars["F0"]),
                       method=rep(c(rep("add",4),"rep"),max(data$age)/5))

## Initial condition: assuming that E/W = rho/v and E+W=ER, then W
## + W*rho/v = ER, W(1+rho/v)=ER, W=ER/(1+rho/v)
y0 <- c(F=unname(pars["F0"]),
        E=0,
        W=unname(5.39e-5/(1+pars["rho"]/pars["v"])),
        P=1)
y0["E"] <- unname(y0["W"]*pars["rho"]/pars["v"])

## Simulate the system
try(ode(y0,
        times=seq(0,35,0.1),
        func="derivs",
        parms=pars,
        dllname="tm_deb_parasite_3",
        initfunc="initmod",
        events=list(data=eventdat))) -> out
as.data.frame(out[out[,'time']%in%data$age,]) -> pred

## compute the observed weight as Wobs = W + E and compute the observed length prediction as Wobs=xi*Lobs^q; (Wobs/xi)^(1/q)=Lobs
xi <- 1.8e-3; q <- 3;
mutate(pred, Wobs=W+E, Lobs=(Wobs/xi)^(1/q)) -> pred

## compute the probability of observing the data, given the prediction
sapply(unique(data$age),
       function(d)
           c(dnorm(x=data$length[data$age==d],
                   mean=pred$Lobs[pred$time==d],
                   sd=pars["Lobs"],
                   log=TRUE) %>% sum,
             dnorm(x=data$spores[data$age==d],
                   mean=pred$P[pred$time==d],
                   sd=pars["Pobs"],
                   log=TRUE) %>% sum
             ) %>% sum
       ) %>% sum -> lik

tm_obj(par_transform(estpars, transform),
       data, fixpars, parorder, transform)

optimizer(estpars, fixpars, parorder, transform, data, eval.only=TRUE, method="Nelder-Mead")
tryout <- optimizer(estpars, fixpars, parorder, transform, data, eval.only=FALSE, method="Nelder-Mead")

## simulate the system at these parameters
pars <- c(tryout$params, fixpars)
pars[match(parorder, names(pars))] -> pars
try(ode(y0,
        times=seq(0,35,0.1),
        func="derivs",
        parms=pars,
        dllname="tm_deb_parasite_3",
        initfunc="initmod",
        events=list(data=eventdat))) %>% as.data.frame %>%
            mutate(., Wobs=W+E, Lobs=(Wobs/xi)^(1/q)) -> out

## Okay, so it's clear what is going on here. The algorithm is essentially pushing the observation error on spores to be huge and just letting everything else go. It's not fitting anything very well at all. I really, really need to be able to fix the observation error on spores at something and then work everything else out.

## parameters fixed at the uninfected data values, with parasite observation error fixed at 1000
fixpars <- c(rho=0.152, K=0.68, km=0.073, v=10, F0=1e6/30, Lobs=0.0102, Pobs=1000)
## unconstrained scale transformation
transform <- rep('log',2)
parorder <- c("rho","K","km","v","F0","Lobs","aP","eP","Pobs")

## Estimate the parameters
box <- cbind(lower=c(aP=1e-10, eP=1e5),
             upper=c(aP=1e-4, eP=1e10))
sobolDesign(lower=box[,'lower'],
            upper=box[,'upper'],
            nseq=300) %>%
                apply(., 1, as.list) %>%
                    lapply(., unlist) -> guesses
## Estimate likelihood
mclapply(guesses,
         optimizer,
         fixpars=fixpars,
         parorder=parorder,
         transform=transform,
         obsdata=data,
         eval.only=TRUE,
         type="trajectory_matching",
         mc.cores=5) %>%
             lapply(., function(x) x$lik) %>%
                 unlist -> guess_lik

guesses[order(guess_lik)[1:5]] -> refine

mclapply(refine,
         optimizer,
         fixpars=fixpars,
         parorder=parorder,
         transform=transform,
         obsdata=data,
         eval.only=FALSE,
         type='trajectory_matching',
         method='Nelder-Mead',
         mc.cores=5) -> refine_lik
saveRDS(refine_lik, file="TM_parameter_estimates_infecteds_model_3.RDS")


## In reality, I really have to sweep across a bunch of observation errors
